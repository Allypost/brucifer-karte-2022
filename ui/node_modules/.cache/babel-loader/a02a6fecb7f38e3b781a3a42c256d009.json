{"ast":null,"code":"export function findChild(node, tagName) {\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i]; // `nodeType: 1` means \"Element\".\n    // https://www.w3schools.com/xml/prop_element_nodetype.asp\n\n    if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n      return childNode;\n    }\n\n    i++;\n  }\n}\nexport function findChildren(node, tagName) {\n  var results = [];\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i]; // `nodeType: 1` means \"Element\".\n    // https://www.w3schools.com/xml/prop_element_nodetype.asp\n\n    if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n      results.push(childNode);\n    }\n\n    i++;\n  }\n\n  return results;\n}\nexport function forEach(node, tagName, func) {\n  // if (typeof tagName === 'function') {\n  // \tfunc = tagName\n  // \ttagName = undefined\n  // }\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i];\n\n    if (tagName) {\n      // `nodeType: 1` means \"Element\".\n      // https://www.w3schools.com/xml/prop_element_nodetype.asp\n      if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n        func(childNode, i);\n      }\n    } else {\n      func(childNode, i);\n    }\n\n    i++;\n  }\n}\nexport function map(node, tagName, func) {\n  var results = [];\n  forEach(node, tagName, function (node, i) {\n    results.push(func(node, i));\n  });\n  return results;\n}\nvar NAMESPACE_REG_EXP = /.+\\:/;\nexport function getTagName(element) {\n  // For some weird reason, if an element is declared as,\n  // for example, `<x:sheets/>`, then its `.tagName` will be\n  // \"x:sheets\" instead of just \"sheets\".\n  // https://gitlab.com/catamphetamine/read-excel-file/-/issues/25\n  // Its not clear how to tell it to ignore any namespaces\n  // when getting `.tagName`, so just replacing anything\n  // before a colon, if any.\n  return element.tagName.replace(NAMESPACE_REG_EXP, '');\n} // This function is only used for occasional debug messages.\n\nexport function getOuterXml(node) {\n  // `nodeType: 1` means \"Element\".\n  // https://www.w3schools.com/xml/prop_element_nodetype.asp\n  if (node.nodeType !== 1) {\n    return node.textContent;\n  }\n\n  var xml = '<' + getTagName(node);\n  var j = 0;\n\n  while (j < node.attributes.length) {\n    xml += ' ' + node.attributes[j].name + '=' + '\"' + node.attributes[j].value + '\"';\n    j++;\n  }\n\n  xml += '>';\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    xml += getOuterXml(node.childNodes[i]);\n    i++;\n  }\n\n  xml += '</' + getTagName(node) + '>';\n  return xml;\n}","map":{"version":3,"mappings":"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","names":["findChild","node","tagName","i","childNodes","length","childNode","nodeType","getTagName","findChildren","results","push","forEach","func","map","NAMESPACE_REG_EXP","element","replace","getOuterXml","textContent","xml","j","attributes","name","value"],"sources":["../../source/xml/dom.js"],"sourcesContent":["export function findChild(node, tagName) {\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\t// `nodeType: 1` means \"Element\".\r\n\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nexport function findChildren(node, tagName) {\r\n\tconst results = []\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\t// `nodeType: 1` means \"Element\".\r\n\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\tresults.push(childNode)\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn results\r\n}\r\n\r\nexport function forEach(node, tagName, func) {\r\n\t// if (typeof tagName === 'function') {\r\n\t// \tfunc = tagName\r\n\t// \ttagName = undefined\r\n\t// }\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\tif (tagName) {\r\n\t\t\t// `nodeType: 1` means \"Element\".\r\n\t\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\t\tfunc(childNode, i)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfunc(childNode, i)\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nexport function map(node, tagName, func) {\r\n\tconst results = []\r\n\tforEach(node, tagName, (node, i) => {\r\n\t\tresults.push(func(node, i))\r\n\t})\r\n\treturn results\r\n}\r\n\r\nconst NAMESPACE_REG_EXP = /.+\\:/\r\nexport function getTagName(element) {\r\n\t// For some weird reason, if an element is declared as,\r\n\t// for example, `<x:sheets/>`, then its `.tagName` will be\r\n\t// \"x:sheets\" instead of just \"sheets\".\r\n\t// https://gitlab.com/catamphetamine/read-excel-file/-/issues/25\r\n\t// Its not clear how to tell it to ignore any namespaces\r\n\t// when getting `.tagName`, so just replacing anything\r\n\t// before a colon, if any.\r\n\treturn element.tagName.replace(NAMESPACE_REG_EXP, '')\r\n}\r\n\r\n// This function is only used for occasional debug messages.\r\nexport function getOuterXml(node) {\r\n\t// `nodeType: 1` means \"Element\".\r\n\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\tif (node.nodeType !== 1) {\r\n\t\treturn node.textContent\r\n\t}\r\n\r\n  let xml = '<' + getTagName(node)\r\n\r\n  let j = 0\r\n  while (j < node.attributes.length) {\r\n    xml += ' ' + node.attributes[j].name + '=' + '\"' + node.attributes[j].value + '\"'\r\n    j++\r\n  }\r\n\r\n  xml += '>'\r\n\r\n  let i = 0\r\n  while (i < node.childNodes.length) {\r\n  \txml += getOuterXml(node.childNodes[i])\r\n    i++\r\n  }\r\n\r\n  xml += '</' + getTagName(node) + '>'\r\n\r\n  return xml\r\n}"]},"metadata":{},"sourceType":"module"}