{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport parseDate from '../parseDate.js';\nimport Integer, { isInteger } from '../../types/Integer.js';\nimport URL, { isURL } from '../../types/URL.js';\nimport Email, { isEmail } from '../../types/Email.js';\nvar DEFAULT_OPTIONS = {\n  isColumnOriented: false\n};\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\n\nexport default function (data, schema, options) {\n  if (options) {\n    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n\n  var _options = options,\n      isColumnOriented = _options.isColumnOriented,\n      rowMap = _options.rowMap,\n      ignoreEmptyRows = _options.ignoreEmptyRows;\n  validateSchema(schema);\n\n  if (isColumnOriented) {\n    data = transpose(data);\n  }\n\n  var columns = data[0];\n  var results = [];\n  var errors = [];\n\n  for (var i = 1; i < data.length; i++) {\n    var result = read(schema, data[i], i, columns, errors, options);\n\n    if (result !== null || ignoreEmptyRows === false) {\n      results.push(result);\n    }\n  } // Correct error rows.\n\n\n  if (rowMap) {\n    for (var _iterator = _createForOfIteratorHelperLoose(errors), _step; !(_step = _iterator()).done;) {\n      var error = _step.value; // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // `- 1` converts row number to row index.\n      // `+ 1` converts row index to row number.\n\n      error.row = rowMap[error.row - 1] + 1;\n    }\n  }\n\n  return {\n    rows: results,\n    errors: errors\n  };\n}\n\nfunction read(schema, row, rowIndex, columns, errors, options) {\n  var object = {};\n  var isEmptyObject = true;\n\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    var schemaEntry = schema[key];\n    var isNestedSchema = _typeof(schemaEntry.type) === 'object' && !Array.isArray(schemaEntry.type);\n    var rawValue = row[columns.indexOf(key)];\n\n    if (rawValue === undefined) {\n      rawValue = null;\n    }\n\n    var value = void 0;\n    var error = void 0;\n    var reason = void 0;\n\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options);\n    } else {\n      if (rawValue === null) {\n        value = null;\n      } else if (Array.isArray(schemaEntry.type)) {\n        var notEmpty = false;\n        var array = parseArray(rawValue).map(function (_value) {\n          var result = parseValue(_value, schemaEntry, options);\n\n          if (result.error) {\n            value = _value;\n            error = result.error;\n            reason = result.reason;\n          }\n\n          if (result.value !== null) {\n            notEmpty = true;\n          }\n\n          return result.value;\n        });\n\n        if (!error) {\n          value = notEmpty ? array : null;\n        }\n      } else {\n        var result = parseValue(rawValue, schemaEntry, options);\n        error = result.error;\n        reason = result.reason;\n        value = error ? rawValue : result.value;\n      }\n    }\n\n    if (!error && value === null && schemaEntry.required) {\n      error = 'required';\n    }\n\n    if (error) {\n      error = {\n        error: error,\n        row: rowIndex + 1,\n        column: key,\n        value: value\n      };\n\n      if (reason) {\n        error.reason = reason;\n      }\n\n      if (schemaEntry.type) {\n        error.type = schemaEntry.type;\n      }\n\n      errors.push(error);\n    } else {\n      if (isEmptyObject && value !== null) {\n        isEmptyObject = false;\n      }\n\n      if (value !== null || options.includeNullValues) {\n        object[schemaEntry.prop] = value;\n      }\n    }\n  };\n\n  for (var _i = 0, _Object$keys = Object.keys(schema); _i < _Object$keys.length; _i++) {\n    _loop();\n  }\n\n  if (isEmptyObject) {\n    return null;\n  }\n\n  return object;\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\n\n\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return {\n      value: null\n    };\n  }\n\n  var result;\n\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse);\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(value, // Supports parsing array types.\n    // See `parseArray()` function for more details.\n    // Example `type`: String[]\n    // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\n    // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n    Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options);\n  } else {\n    result = {\n      value: value\n    }; // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n  } // If errored then return the error.\n\n\n  if (result.error) {\n    return result;\n  }\n\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return {\n        error: 'invalid',\n        reason: 'unknown'\n      };\n    }\n\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value);\n      } catch (error) {\n        return {\n          error: error.message\n        };\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\n\nfunction parseCustomValue(value, parse) {\n  try {\n    value = parse(value);\n\n    if (value === undefined) {\n      return {\n        value: null\n      };\n    }\n\n    return {\n      value: value\n    };\n  } catch (error) {\n    return {\n      error: error.message\n    };\n  }\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\n\n\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      if (typeof value === 'string') {\n        return {\n          value: value\n        };\n      } // Excel tends to perform a forced automatic convertion of string-type values\n      // to number-type ones when the user has input them. Otherwise, users wouldn't\n      // be able to perform formula calculations on those cell values because users\n      // won't bother manually choosing a \"numeric\" cell type for each cell, and\n      // even if they did, choosing a \"numeric\" cell type every time wouldn't be an\n      // acceptable \"user experience\".\n      //\n      // So, if a cell value is supposed to be a string and Excel has automatically\n      // converted it to a number, perform a backwards conversion.\n      //\n\n\n      if (typeof value === 'number') {\n        if (isNaN(value)) {\n          return {\n            error: 'invalid',\n            reason: 'invalid_number'\n          };\n        } // The global `isFinite()` function filters out:\n        // * NaN\n        // * -Infinity\n        // * Infinity\n        //\n        // All other values pass (including non-numbers).\n        //\n\n\n        if (!isFinite(value)) {\n          return {\n            error: 'invalid',\n            reason: 'out_of_bounds'\n          };\n        }\n\n        return {\n          value: String(value)\n        };\n      }\n\n      return {\n        error: 'invalid',\n        reason: 'not_a_string'\n      };\n\n    case Number:\n    case Integer:\n      // An XLSX file editing software might not always correctly\n      // detect numeric values in string-type cells. Users won't bother\n      // manually selecting a cell type, so the editing software has to guess\n      // based on the user's input. One can assume that such auto-detection\n      // might not always work.\n      //\n      // So, if a cell is supposed to be a numeric one, convert a string value to a number.\n      //\n      if (typeof value === 'string') {\n        var stringifiedValue = value;\n        value = Number(value);\n\n        if (String(value) !== stringifiedValue) {\n          return {\n            error: 'invalid',\n            reason: 'not_a_number'\n          };\n        }\n      }\n\n      if (typeof value !== 'number') {\n        return {\n          error: 'invalid',\n          reason: 'not_a_number'\n        };\n      }\n\n      if (isNaN(value)) {\n        return {\n          error: 'invalid',\n          reason: 'invalid_number'\n        };\n      } // At this point, `value` can only be a number.\n      //\n      // The global `isFinite()` function filters out:\n      // * NaN\n      // * -Infinity\n      // * Infinity\n      //\n      // All other values pass (including non-numbers).\n      //\n\n\n      if (!isFinite(value)) {\n        return {\n          error: 'invalid',\n          reason: 'out_of_bounds'\n        };\n      }\n\n      if (type === Integer && !isInteger(value)) {\n        return {\n          error: 'invalid',\n          reason: 'not_an_integer'\n        };\n      }\n\n      return {\n        value: value\n      };\n\n    case URL:\n      if (typeof value === 'string') {\n        if (isURL(value)) {\n          return {\n            value: value\n          };\n        }\n\n        return {\n          error: 'invalid',\n          reason: 'not_a_url'\n        };\n      }\n\n      return {\n        error: 'invalid',\n        reason: 'not_a_string'\n      };\n\n    case Email:\n      if (typeof value === 'string') {\n        if (isEmail(value)) {\n          return {\n            value: value\n          };\n        }\n\n        return {\n          error: 'invalid',\n          reason: 'not_an_email'\n        };\n      }\n\n      return {\n        error: 'invalid',\n        reason: 'not_a_string'\n      };\n\n    case Date:\n      // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n      if (value instanceof Date) {\n        if (isNaN(value)) {\n          return {\n            error: 'invalid',\n            reason: 'out_of_bounds'\n          };\n        }\n\n        return {\n          value: value\n        };\n      }\n\n      if (typeof value === 'number') {\n        if (isNaN(value)) {\n          return {\n            error: 'invalid',\n            reason: 'invalid_number'\n          };\n        }\n\n        if (!isFinite(value)) {\n          return {\n            error: 'invalid',\n            reason: 'out_of_bounds'\n          };\n        }\n\n        var date = parseDate(value, options.properties);\n\n        if (isNaN(date)) {\n          return {\n            error: 'invalid',\n            reason: 'out_of_bounds'\n          };\n        }\n\n        return {\n          value: date\n        };\n      }\n\n      return {\n        error: 'invalid',\n        reason: 'not_a_date'\n      };\n\n    case Boolean:\n      if (typeof value === 'boolean') {\n        return {\n          value: value\n        };\n      }\n\n      return {\n        error: 'invalid',\n        reason: 'not_a_boolean'\n      };\n\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type);\n      }\n\n      throw new Error(\"Unknown schema type: \".concat(type && type.name || type));\n  }\n}\n\nexport function getBlock(string, endCharacter, startIndex) {\n  var i = 0;\n  var substring = '';\n  var character;\n\n  while (startIndex + i < string.length) {\n    var _character = string[startIndex + i];\n\n    if (_character === endCharacter) {\n      return [substring, i];\n    } else if (_character === '\"') {\n      var block = getBlock(string, '\"', startIndex + i + 1);\n      substring += block[0];\n      i += '\"'.length + block[1] + '\"'.length;\n    } else {\n      substring += _character;\n      i++;\n    }\n  }\n\n  return [substring, i];\n}\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\n\nexport function parseArray(string) {\n  var blocks = [];\n  var index = 0;\n\n  while (index < string.length) {\n    var _getBlock = getBlock(string, ',', index),\n        _getBlock2 = _slicedToArray(_getBlock, 2),\n        substring = _getBlock2[0],\n        length = _getBlock2[1];\n\n    index += length + ','.length;\n    blocks.push(substring.trim());\n  }\n\n  return blocks;\n} // Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\n\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (row) {\n      return row[i];\n    });\n  });\n};\n\nfunction validateSchema(schema) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(schema); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var entry = schema[key];\n\n    if (!entry.prop) {\n      throw new Error(\"\\\"prop\\\" not defined for schema entry \\\"\".concat(key, \"\\\".\"));\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["parseDate","Integer","isInteger","URL","isURL","Email","isEmail","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","ignoreEmptyRows","validateSchema","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","rowIndex","object","isEmptyObject","key","schemaEntry","isNestedSchema","_typeof","type","Array","isArray","rawValue","indexOf","undefined","value","reason","notEmpty","array","parseArray","map","_value","parseValue","required","column","includeNullValues","prop","Object","keys","_loop","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","String","isNaN","isFinite","Number","stringifiedValue","Date","date","properties","Boolean","Error","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"sources":["../../../source/read/schema/convertToJson.js"],"sourcesContent":["import parseDate from '../parseDate.js'\r\n\r\nimport Integer, { isInteger } from '../../types/Integer.js'\r\nimport URL, { isURL } from '../../types/URL.js'\r\nimport Email, { isEmail } from '../../types/Email.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap,\r\n    ignoreEmptyRows\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i, columns, errors, options)\r\n    if (result !== null || ignoreEmptyRows === false) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // `- 1` converts row number to row index.\r\n      // `+ 1` converts row index to row number.\r\n      error.row = rowMap[error.row - 1] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  let isEmptyObject = true\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    let reason\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n            reason = result.reason\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        reason = result.reason\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (reason) {\r\n        error.reason = reason\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else {\r\n      if (isEmptyObject && value !== null) {\r\n        isEmptyObject = false\r\n      }\r\n      if (value !== null || options.includeNullValues) {\r\n        object[schemaEntry.prop] = value\r\n      }\r\n    }\r\n  }\r\n  if (isEmptyObject) {\r\n    return null\r\n  }\r\n  return object\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid', reason: 'unknown' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      if (typeof value === 'string') {\r\n        return { value }\r\n      }\r\n      // Excel tends to perform a forced automatic convertion of string-type values\r\n      // to number-type ones when the user has input them. Otherwise, users wouldn't\r\n      // be able to perform formula calculations on those cell values because users\r\n      // won't bother manually choosing a \"numeric\" cell type for each cell, and\r\n      // even if they did, choosing a \"numeric\" cell type every time wouldn't be an\r\n      // acceptable \"user experience\".\r\n      //\r\n      // So, if a cell value is supposed to be a string and Excel has automatically\r\n      // converted it to a number, perform a backwards conversion.\r\n      //\r\n      if (typeof value === 'number') {\r\n        if (isNaN(value)) {\r\n          return { error: 'invalid', reason: 'invalid_number' }\r\n        }\r\n        // The global `isFinite()` function filters out:\r\n        // * NaN\r\n        // * -Infinity\r\n        // * Infinity\r\n        //\r\n        // All other values pass (including non-numbers).\r\n        //\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid', reason: 'out_of_bounds' }\r\n        }\r\n        return { value: String(value) }\r\n      }\r\n      return { error: 'invalid', reason: 'not_a_string' }\r\n\r\n    case Number:\r\n    case Integer:\r\n      // An XLSX file editing software might not always correctly\r\n      // detect numeric values in string-type cells. Users won't bother\r\n      // manually selecting a cell type, so the editing software has to guess\r\n      // based on the user's input. One can assume that such auto-detection\r\n      // might not always work.\r\n      //\r\n      // So, if a cell is supposed to be a numeric one, convert a string value to a number.\r\n      //\r\n      if (typeof value === 'string') {\r\n        const stringifiedValue = value\r\n        value = Number(value)\r\n        if (String(value) !== stringifiedValue) {\r\n          return { error: 'invalid', reason: 'not_a_number' }\r\n        }\r\n      }\r\n      if (typeof value !== 'number') {\r\n        return { error: 'invalid', reason: 'not_a_number' }\r\n      }\r\n      if (isNaN(value)) {\r\n        return { error: 'invalid', reason: 'invalid_number' }\r\n      }\r\n      // At this point, `value` can only be a number.\r\n      //\r\n      // The global `isFinite()` function filters out:\r\n      // * NaN\r\n      // * -Infinity\r\n      // * Infinity\r\n      //\r\n      // All other values pass (including non-numbers).\r\n      //\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid', reason: 'out_of_bounds' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid', reason: 'not_an_integer' }\r\n      }\r\n      return { value }\r\n\r\n    case URL:\r\n      if (typeof value === 'string') {\r\n        if (isURL(value)) {\r\n          return { value }\r\n        }\r\n        return { error: 'invalid', reason: 'not_a_url' }\r\n      }\r\n      return { error: 'invalid', reason: 'not_a_string' }\r\n\r\n    case Email:\r\n      if (typeof value === 'string') {\r\n        if (isEmail(value)) {\r\n          return { value }\r\n        }\r\n        return { error: 'invalid', reason: 'not_an_email' }\r\n      }\r\n      return { error: 'invalid', reason: 'not_a_string' }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        if (isNaN(value)) {\r\n          return { error: 'invalid', reason: 'out_of_bounds' }\r\n        }\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (isNaN(value)) {\r\n          return { error: 'invalid', reason: 'invalid_number' }\r\n        }\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid', reason: 'out_of_bounds' }\r\n        }\r\n        const date = parseDate(value, options.properties)\r\n        if (isNaN(date)) {\r\n          return { error: 'invalid', reason: 'out_of_bounds' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid', reason: 'not_a_date' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid', reason: 'not_a_boolean' }\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}